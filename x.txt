[{'patternName': 'Singleton', 'patternUMLFileName': 'singleton.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/singleton', 'patternId': 'Singleton', 'patternStructure': "* Structure\n\nThe fact that every class has a public constructor in Java can be used in order to implement a Singleton. \nThe public constructor will be overridden with a new constructor which does nothing, but the scope of the constructor is private, \nso other classes can't instantiate class objects.\n\n\nThe object is created in the method getInstance(), and since an object is created when method getInstance() is invoked for first time, \nwe are talking about lazy instantiation technique.\n\n\nThis technique ensures that singleton instances are created only when needed.\n\n\nThis implementation may have issues in multithreaded environment, but in such situation we have synchronize method getInstance(), \nor a block inside that method.\n\n\n\n", 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/singleton.jpg "Usain Bolt, Men\'s 100 meters world record holder")  \n###### Brick Lane Graffiti Usain Bolt&nbsp;(<a rel=\'license\' href=\'https://creativecommons.org/licenses/by/2.0/\' target=\'_blank\'>CC BY 2.0</a>)&nbsp;by&nbsp;<a xmlns:cc=\'http://creativecommons.org/ns#\' rel=\'cc:attributionURL\' property=\'cc:attributionName\' href=\'https://www.flickr.com/people/mdpettitt/\' target=\'_blank\'>Martin Pettitt</a>\n\n', 'patternStory': '\nMen\'s 100 meters world record holder is a singleton. \nThere can be only one active "Men\'s 100 meters world record holder" at any given time. \nRegardless of the actual person who holds this title, "Men\'s 100 meters world record holder" is a global point of access that \nidentifies the fastest person in the world.\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/singleton', 'patternMotivation': "\nObjects reside inside heap memory, and we can instantiate as many objects as the physical space in the heap memory will allow. \nBut, in some cases, we can have a situation when only one instance of a class can be instantiated.\nSo, imagine that we are developing a program which is playing audio files. Inside that program, we need to have a class which handles audio output. \nA computer usually has one audio output, so no more than one sound can be played at a time. \nTherefore, a class that handles the computer audio device should have exactly one instance.\n\nHow can we ensure that only one instance is created?\nEach java class has default public constructor, which can be invoked from any part of the code.\nIf we implement a class where default constructor has scope 'private', \nthen only the methods from that class can invoke that constructor, meaning that we can't instantiate that class from other classes. \nThis is a basis of the Singleton pattern.\n\nThe Singleton ensures that only one (single) object can be created from the class.\n\n\n"}, {'patternName': 'Prototype', 'patternUMLFileName': 'prototype.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/prototype', 'patternId': 'Prototype', 'patternStructure': '* Structure\n\nThe Prototype interface defines the cloneMe() method.  \nThe ConcretePrototype implements a Prototype interface using java.lang.Object.clone() method.\n\n\nThe prototype can be used to implement a copy constructor (deep or shallow).\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/prototype.jpg "Sheep Dolly")  \n###### <a href="https://commons.wikimedia.org/wiki/File:Dolly_the_sheep_2016.JPG">Dolly the sheep 2016</a>, By Geni,<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC BY-SA 4.0</a>\n\n', 'patternStory': '\nThe Clone itself.\n\n\nDolly the sheep was the first mammal to be cloned, so Dolly is a duplicate.\n\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/prototype', 'patternMotivation': '\nIn Singleton pattern we saw how to tackle the situation when we should instantiate a single object of a class. \nHowever, we may have a situation when, during runtime, we want to copy an object which already exists in memory, particularly if the object is complex.\n\n\nSo, imagine that we are developing software which can work with spreadsheets. A spreadsheet consist of cells, and a cell is a complex object with lot of attributes, such as borders, content, format, color, etc. Now, if we want to split a cell, we can develop a method which will copy each attribute of that object. This method can became very complex, so we should consider a more elegant solution.\nIt would be nice if we could copy an object with a single method, for example cloneMe().\n\nSuch solution is a Prototype pattern.\n\n'}, {'patternName': 'Builder', 'patternUMLFileName': 'builder.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/builder', 'patternId': 'Builder', 'patternStructure': '* Structure\n\nThe Product class represents a complex object. \nThe Builder specifies an abstract interface for creating parts of a Product object.  \nThe ConcreteBuilder class constructs and assembles parts of the product, implementing the Builder interface.   \nThe Director class constructs an object using the Builder interface.\n\n  \n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/builder.jpg "The Antec P180, a popular computer case, suitable for use as a silent PC")  \n###### The Antec P180, By DonES (Own work) [<a href="http://www.gnu.org/copyleft/fdl.html">GFDL</a> or <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA-3.0</a>], <a href="https://commons.wikimedia.org/wiki/File%3ASilent_PC-Antec_P180.JPG">via Wikimedia Commons</a>\n\n', 'patternStory': '\nThis pattern is used by PC shops to construct PCs. \nPC is a combination of various parts, such as a CPU, a motherboard, memory, storage, power supply, video card, etc. \nTo build a PC, the same construction process is used, even if we have different variations for each part. \nWhether a customer picks a classical hard disk or SSD for storage, the construction process is the same.\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/builder', 'patternMotivation': '\nThe Builder, as the name suggests, builds complex objects from simple ones, step-by-step.\n\n\nLet\xe2\x80\x99s say we order a child meal at a fast food restaurant. What is it comprised of? Well, a burger, a cold drink, fries and a toy. \nIn fact, a child meal consist of a main item, a side item, a drink and a toy.\n\n\nEvery time a child meal is ordered, the service boy will take a burger, fries, a cold drink and a toy. \nNow suppose that there are 3 types of burgers available \xe2\x80\x93 Cheese, Beef and Chicken, 2 types of cold drinks available \xe2\x80\x93 Cola and \nOrange, and 2 types of toys available \xe2\x80\x93 a car and a doll.\n\n\nSo, the order might be a combination of one of these, but the process of building a child meal will be the same. \nOne burger, one cold drink, fries and one toy. All these items are placed in a paper bag, which is given to the customer. \nThe process of producing a child meal is an example of the Builder pattern.\n\n\nThe Builder pattern separates construction of a complex object from its representation, so that the same construction process can create different representations.\n\n'}, {'patternName': 'Factory Method', 'patternUMLFileName': 'factorymethod.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/factorymethod', 'patternId': 'FactoryMethod', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/factorymethod.jpg "Cake molds, Han people, metal - Museum of Vietnamese History - Ho Chi Minh City")  \n###### Cake molds, Han people, metal - Museum of Vietnamese History - Ho Chi Minh City, By Daderot (Own work) [<a href="http://creativecommons.org/publicdomain/zero/1.0/deed.en">CC0</a>], <a href="https://commons.wikimedia.org/wiki/File%3ACake_molds%2C_Han_people%2C_metal_-_Museum_of_Vietnamese_History_-_Ho_Chi_Minh_City_-_DSC05796.JPG">via Wikimedia Commons</a>\n\n', 'patternStory': '\nPlasticine is used as a toy for children. Plasticine is injected into predefined molds. \nThe class of end product (ball, toy, sculpture, cake) is determined by the mold.\n\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/factorymethod', 'patternMotivation': '\nImagine that we need to develop a reporting library. \nTwo basic abstractions in this library are the Engine and the Report classes. \nBoth classes are abstract, and clients have to extend them in order to realize their application specific implementations.\n\n\nThe Engine class is responsible for managing Reports and will create them as required. \nReport subclasses which Engine should instantiate are application\xe2\x80\x93specific and Engine only knows when a new report should be created, \nbut not what type of Report to create. \nThis leads us to a situation in which our library should instantiate classes, but it only knows about abstract classes, which it cannot instantiate.\n\n\nSo, how can we solve this?\n\n\nIf we encapsulate the knowledge of which Report subclasses to create and move this knowledge outside of the library, then \nEngine subclass will be able to create Report objects. This solution is the Factory Method pattern.\n\n\nThe Factory Method defines an interface for creating objects, but lets subclasses decide which class to instantiate.\n\n\n'}, {'patternName': 'Abstract Factory', 'patternUMLFileName': 'abstractfactory.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/abstractfactory', 'patternId': 'AbstractFactory', 'patternStructure': '* Structure\n\nThe AbstractFactory defines the interface for creation of the abstract product objects. \nThe AbstractProduct defines the interface for product objects. \nThe ConcreteProduct class implements products based on AbstractProduct interfaces. \nThe ConcreteFactory class implements factories based on AbstractFactory interfaces. \nThe Client class uses AbstractFactory & AbstractProduct interfaces.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/abstractfactory.jpg "Poker Cards Back")  \n###### Poker Cards Back&nbsp;(<a rel=\'license\' href=\'https://creativecommons.org/share-your-work/public-domain/cc0/\' target=\'_blank\'>CC 0</a>)\n\n\n\n\n', 'patternStory': '\nThis pattern is found in the cards stamping equipment, used in manufacturing of playing cards. \nA card stamping machine is an Abstract Factory which produces cards. \nThe same machine is used to stamp French, Italian or German cards. \n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/abstractfactory', 'patternMotivation': '\n\nImagine that we are developing a framework for a GUI environment, were windows will be drawn on a display device and the user will \ninteract with the GUI using a mouse and a keyboard.\n\nThe first version of the framework will support Windows OS, so Factory method is used for creation of the graphical abstractions \nlike Frame, Window, ScrollBar, etc.\n\n\nIn the next version, the framework will be extended to Linux OS. So, how should we extend our factory method?\n\n\nOne way would be to introduce factory abstraction, where each OS will have dedicated factory for creation of the graphical abstractions. \nThe proposed solution is an example of the Abstract Factory.\n\nThe Abstract Factory is one level higher in abstraction than the Factory Method. \nThe Factory Method abstracts the way objects are created, while the Abstract Factory also abstracts the way factories are created, \nwhich in turn abstracts the way objects are created.\n\n\nThe Abstract Factory provides an interface for creating families of related objects, without specifying concrete classes.\n\n\n'}, {'patternName': 'Adapter', 'patternUMLFileName': 'adapter.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/adapter', 'patternId': 'Adapter', 'patternStructure': '* Structure\n\nWe can have two implementations, the Class adapter and the Object adapter.\n\n\nThe Class adapter extends the Adaptee class. \nThe Object adapter injects Adaptee object into the Adapter class.\n\n\nThe target interface defines the domain-specific interface used by the Client. \nThe Client class uses the target interface. \nThe Adaptee class defines an existing interface where adaption will be applied. \nThe Adapter class adapts interface Adaptee to the Target.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/adapter.jpg "Adapter")  \n###### <a href="https://commons.wikimedia.org/wiki/User:Lionel_Allorge">Lionel Allorge</a>, <a href="https://commons.wikimedia.org/wiki/File:Adaptateur_de_prise_fran\xc3\xa7aise_en_prise_suisse_2.jpg">Adaptateur de prise fran\xc3\xa7aise en prise suisse 2</a>, <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a>\n\n', 'patternStory': '\nAdapters are often used in daily life, for example, an electrical adapter is a device that converts attributes of one electrical device or \nsystem to those of an otherwise incompatible device or system. \nSome modify power or signal attributes, while others merely adapt the physical form of one electrical connector to another.\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/adapter', 'patternMotivation': "\nImagine that we need to develop a graphical editor which should be able to draw various graphical shapes like line, circle, rectangle and text. \nAll of our graphical elements are subclass of the base class Shape. So, we will have LineShape, CircleShape, RectangeShape and TextShape.\n\n\nThe implementation of the TextShape is not easy. \nWe need to implement a lot of complex functionalities, such as text buffering, text bolding, text coloring, undo, redo, \n'what you see is what you get', etc. We have found an open source text library which implements pretty much all of the text functionality \nwhich we are looking for.\n\n\nWhy not adapt an existing text library, so that we can reuse already implemented functionality for our graphical editor? \nBut, in order to use the existing text library, we must adapt interfaces from the existing text library to our interfaces.\n\n\nThe process of adaptation of the existing interfaces is an example of the Adapter pattern.\n\n\nThe adapter allows us to access the interface of an existing class from another interface.\n\n\n"}, {'patternName': 'Bridge', 'patternUMLFileName': 'bridge.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/bridge', 'patternId': 'Bridge', 'patternStructure': '* Structure\n\nThe Implementator interface defines the interface for implementation classes (concrete implementers). \nThe ConcreteImplementator class implements the Implementator interface and defines its concrete implementation. \nThe Abstraction abstract class defines the abstraction interface, maintains a reference to an object of type Implementator, \nand the link between the abstraction and the implementer is called a Bridge. \nThe RefinedAbstracion extends the interface defined by Abstraction.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/bridge.jpg "1924 Stanley 740 Interior")  \n###### 1924 Stanley 740 Interior, By Liftarn (Own work) [Public domain], <a href="https://commons.wikimedia.org/wiki/File%3A1924Stanley740-interior.jpg">via Wikimedia Commons</a>\n\n', 'patternStory': "\nA steering wheel is an example of the Bridge. \nThe purpose of a steering wheel is to transmit driver's input to the steered wheels in order to dynamically change the direction of the vehicle. \nThere are different implementations of steering wheels used in cars, buses, trucks, tractors and racing cars.\n\n", 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/bridge', 'patternMotivation': "\nLet's say that that we want to develop an audio player on our Windows OS. We define the base class, Audio, which has two subclasses \xe2\x80\x93 MP3Audio and \nWavAudio. The first version of the player on Windows is running well, but after some time we want to implement the same player on Linux OS.\n\n\nHow do we tackle this situation?\n\n\nIf we incorporate the OS specifics in our hierarchy, we will end up with 4 class combinations, such as WindowsMP3Audio, LinuxMP3Audio, \nWindowsWavAudio and LinuxWavAudio. Adding more codec types and more operating systems will make the hierarchy even larger.\n\n\nThe appropriate solution would be to extract our structure into two separate hierarchies.\n\n\nThe original audio structure classes will remain the same,  and they will contain a reference to an object of the new hierarchy, the OS hierarchy. \nThis way we will extract the OS specifics into a class of its own, with two child classes, Windows and Linux. \nThe Audio class will get a reference field to one of the OS classes. \nUsing that reference, it will be able to delegate work to OS objects when needed. \nThis reference will serve as a bridge between the Audio and OS hierarchies.\n\n\nThe explained solution is an example of the Bridge pattern.\n\n\nThe bridge pattern decouples an abstraction from its implementation, so that the two can vary independently.\n\n\n"}, {'patternName': 'Composite', 'patternUMLFileName': 'composite.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/composite', 'patternId': 'Composite', 'patternStructure': '* Structure\n\nThe Component abstract class declares the interface for objects in the composition, implements default behavior for the interface common to \nall classes as appropriate, and declares an interface for accessing and managing its child components. \nThe Leaf class represents leaf objects in the composition. \nThe Composite class defines behavior for components having children, stores the child components and implements the child-related operations in the \nComponent interface.\nThe Client class uses the Composite interface.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/composite.jpg "Lego Bricks")  \n###### Lego Bricks, By Priwo (photo taken by de:Benutzer:Priwo) [Public domain], <a href="https://commons.wikimedia.org/wiki/File%3ALEGO-01.jpg">via Wikimedia Commons</a>\n\n', 'patternStory': '\nLego brick represents a Composite pattern. \nA brick is a basic object, but at the same time, a brick is a container which can hold other bricks in order to construct complex objects.\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/composite', 'patternMotivation': '\nImagine that we need to develop a graphical framework which should speed up the development of business applications, \nwhere the user works with data using graphical forms. \nA graphical form is made up of the basic graphical elements, such as label, text, input field, button, list, etc.\n\n\nIn order to draw something on the screen, each graphical element should implement a common interface with the draw method. \nBut, in addition to the draw interface, some graphical elements must act as containers for other graphical elements. \nSo, for example, a form is a container for labels, input fields and buttons.\n\n\nIt seems that a tree structure can be the basis for such a graphical framework, but the problem is that we must treat a leaf node and an internal \nnode the same way. This problem can be solved by using the Composite pattern.\n\n\nThe Composite pattern composes objects into tree structures to represent part-whole hierarchies. \nA group of objects is to be treated the same way as a single instance of an object.\n\n\n'}, {'patternName': 'Decorator', 'patternUMLFileName': 'decorator.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/decorator', 'patternId': 'Decorator', 'patternStructure': '* Structure\n\nThe Component defines interfaces for new features which will be added dynamically. \nThe ConcreteComponent class defines object where new features can be added. \nThe Decorator abstract class holds reference to the Component object. \nThe ConcreteDecorator class adds new features to the Component object.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/decorator.jpg "013 Porsche 911 Carrera S (8233337583)")  \n######  <a href="https://commons.wikimedia.org/wiki/File:2013_Porsche_911_Carrera_S_(8233337583).jpg">2013 Porsche 911 Carrera S (8233337583)</a>, by <a href="http://www.flickr.com/people/15779944@N00">steve lyon</a> from los angeles, ca, usa,<a href="https://creativecommons.org/licenses/by-sa/2.0/legalcode">CC BY-SA 2.0</a>\n\n', 'patternStory': "\nThe spoilers that are added to a car are examples of the Decorator. \nThe spoilers do not change the car itself, but add additional functionality which is to 'spoil' unfavorable air movement across a body of a vehicle in motion, usually described as turbulence or drag.\n\n\n", 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/decorator', 'patternMotivation': '\nSuppose that we are working on a user interface toolkit and we want to be able to add borders and scroll bars to the windows. \nIf we use inheritance, we will extend Window class with new classes, such as WindowVerticalScrollBar, WindowHorizontalScrollBar, WindowBorder, etc.\n\n\nThe solution with the inheritance is not flexible, since we will end up with too many subclasses. \nSuch a hierarchy is difficult to maintain, difficult to extend and difficult to use.\n\nBut, if we enclose a window in an object which can add new features, such as scroll bar and border dynamically, \nwe will have a much more flexible solution. The "enclosed" object is a decorator.\n\n\nThe Decorator pattern attaches additional responsibilities to an object dynamically.\n\n\nDecorator pattern, attaches additional responsibilities to an object dynamically.\n\n'}, {'patternName': 'Facade', 'patternUMLFileName': 'facade.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/facade', 'patternId': 'Facade', 'patternStructure': '* Structure\n\nThe UML diagram consist of Facade and subsystem classes.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/facade.jpg "Event Management in Pune")  \n###### Event Management in Pune, By WeMaxx1248 (Own work) [<a href="http://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>], <a href="https://commons.wikimedia.org/wiki/File%3AEvent_management_in_pune.jpg">via Wikimedia Commons</a>\n\n', 'patternStory': '\nYou want to organize a marriage reception with dinner for 100 people. \nSo, in order to organize such event, you need to find and decorate a hall where the event will happen, then you need to organize the band, \norganize flowers, send invitations, and so on and so on.\n\nIf this is too much trouble for you, you could hire an event manager who will organize the event for you.\n\nThis is a typical example for Facade.\n \n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/facade', 'patternMotivation': '\nLet\'s say that we need to develop a compiler for a brand new programming language.\n\n\nThe compiling process consist of steps, such as scanning, tokenizing, parsing, building abstract syntax tree, code generation, etc. \nWe need to develop a separate subcomponent for each step. In principle, each subcomponent is complex, and the usage of subcomponents is complex as well.\n\n\nIt does not make sense for a client which wants to compile code to invoke complex subcomponents in order to compile.\n\n\nA better approach would be to define a uniform interface which presents the compiler functionality \xe2\x80\x93 a Compiler class. \nThe Compiler class hides "low-level" functionality from the client, so we can say that Compiler class is a facade.\n\n\nThe Facade design pattern hides the complexity of a system and provides an interface to the client through which the client can access the system.\n\n'}, {'patternName': 'Flyweight', 'patternUMLFileName': 'flyweight.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/flyweight', 'patternId': 'Flyweight', 'patternStructure': '* Structure\n\nThe flyweight pattern uses the concepts of intrinsic and extrinsic data. \nThe intrinsic data is held in the properties of the flyweight objects, which are shared. \nThis information is stateless and generally remains unchanged, as any changes would be effectively replicated among all of the objects that reference \nthe flyweight. Extrinsic data can be state-full, as it is held outside of a flyweight object. \nIt can be passed to methods of a flyweight when needed, but should never be stored within a shared flyweight object.\n\n\nThe Flyweight interface defines interfaces through which flyweight can receive and act on extrinsic states. \nThe ConcreteFlyweight class implements Flyweight and adds storage for intrinsic state (Character). \nThe UnsharedConcreteFlyweight class defines objects which are not shared. \nThe FlyweightFactory class creates and manages the flyweight objects. \nThe Client class keeps flyweight reference and stores extrinsic state.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/flyweight.jpg "Normal Form Diagram")  \n###### Normal Form Diagram, By 04hutts (Own work) [Public domain], <a href="https://commons.wikimedia.org/wiki/File%3ANormalFormDiagram.png">via Wikimedia Commons</a>\n\n', 'patternStory': '\nDatabase normalization is flyweight. \nNormalization is the process of organizing the columns (attributes) and the tables (relations) of a relational database to minimize data redundancy\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/flyweight', 'patternMotivation': "\nLet's imagine that you are teaching youngsters programming. \nYou decided to start with simple but exciting example, so during the course, a graphical editor which can draw a line will be developed.\n\n\nThe Base artifact is a Line class, with start and end point. \nNow a draw method needs to be implemented \xe2\x80\x93 and voila, our simple graphical editor is implemented. \nAfter using the editor for a while, we decide that a new feature should be implemented: in fact, we want our line to have basic colors.\n\n\nThe Line class will be extended with a new attribute (Color class), which holds information about the color, and the draw method will be \nextended accordingly. Now we have a new version of our editor, and some users want to test-drive the editor to its limits, \nso they draw several thousand lines. Drawing several thousand lines means that we have several thousand Line objects in memory, \nbut we also have several thousand Color objects in memory, even if our editor is drawing lines with basic colors only.\n\n\nCan we use memory more efficiently? \nThe Color objects include information that is duplicated. \nWhy not set up a pool of basic color objects and share those colors when a Line object needs it?\n\n\nThe properties of the objects which are shared and are reasonably unchanging are moved into flyweight objects. \nFor each of the Line objects which use the shared data, only a reference to the appropriate flyweight object is required. \nThis will drastically reduce the memory used by each of the Line objects.\n\n\nThe solution used in explanation is an example of the Flyweight pattern. \nThe Flyweight patterns remove duplicates and reduce memory by loading only the data necessary to perform action.\n\n\n"}, {'patternName': 'Proxy', 'patternUMLFileName': 'proxy.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/proxy', 'patternId': 'Proxy', 'patternStructure': '* Structure\n\nThe Subject interface defines a common interface for the RealSubject and the Proxy RealSubject classes and points to the real object which the \nProxy represents. \nThe Proxy class keeps reference to the real subject: it can act as a surrogate, controlling access to the real subject and can be \nresponsible for creation and maintenance of the Real subject.\n\n\nThe Proxy can be used in many situations, therefore we have the following Proxy types:\nThe Remote Proxy - represents an object in a different address space. \nThe Virtual Proxy - creates "heavy" objects on demand. \nThe Protection Proxy - controls access to the object, protects the target from bad clients (Firewall proxy). \nThe Smart reference - replacement for a smart pointer, can be used as a counter of the created objects. \nThe Cache Proxy - stores the results of most frequently used target operations. \nThe Synchronization Proxy - allows safe concurrent accesses to the target object by different client objects. \nThe Counting Proxy - provides audit mechanism before executing a method on the target object.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/proxy.jpg "The Envoy Extraordinary")  \n###### Burmese ambassador, The Envoy Extraordinary and Minister Plenipotentiary, By John Watkins (Kenwoon Mengyee) [Public domain or Public domain], <a href="https://commons.wikimedia.org/wiki/File%3AKinwun_Mingyi.jpg">via Wikimedia Commons</a>\n\n', 'patternStory': '\nAn Envoy Extraordinary is a Proxy. \nHe is an accredited messenger, agent, or representative, who is sent by one government to represent it in dealings with another government.\n\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/proxy', 'patternMotivation': '\nImagine that we are implementing a Viewer application, which will show a Microsoft Word document in read only mode.\n\nThe Viewer must open and load document quickly, but the problem is that during loading of the document, \nwe don\'t know if there are any "heavy" objects inside a document. \nA heavy object can be an image which is injected in a Word document on, let\'s say, page 10 of the document.\n\nSo, a straight solution where we simply load everything that is inside the document can be slow.\n\n\nAnother solution would be that heavy objects are loaded on demand: in our example, \nan image will be loaded when the user is on the page 10 of the document. \nMeanwhile, the heavy object will be presented by another, "lighter" object, which acts as original.\n\n\nThat solution is a Proxy.\n\n\nThe Proxy pattern provides a surrogate or a placeholder for another object to control access to it.\n\n\n'}, {'patternName': 'Chain Of Responsibility', 'patternUMLFileName': 'chainofresponsibility.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/chainofresponsibility', 'patternId': 'ChainOfResponsibility', 'patternStructure': '* Structure\n\nA Handler defines interface for request handling. \nThe ConcreteHandler handles the request, can access the next object in the chain and forward the request if necessary. \nA client initiates requests to the ConcreteHandler.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/chainofresponsibility.jpg "Zulu Soldiers of King Panda\xe2\x80\x99s Army, 1847")  \n###### By George French Angas, 1822-1886 (Biblioth\xc3\xa8que num\xc3\xa9rique mondiale), Zulu Soldiers of King Panda\xe2\x80\x99s Army, 1847 [Public domain], <a href="https://commons.wikimedia.org/wiki/File%3AZulu_soldiers_of_the_army_of_King_Umpande_(Panda)%2C_1847.png">via Wikimedia Commons</a>\n\n\n', 'patternStory': '\nA King and his army is an example of the Chain of Responsibility. \nThe King gives orders to his army. The closest element to react would be the commander, \nthen the officer and then the soldier \xe2\x80\x93 and those three elements would form a Chain of Responsibility.\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/chainofresponsibility', 'patternMotivation': '\nImagine that you just have bought a new wireless router from the local Internet Service Provider. \nYou unpack a router from the box, plug the necessary cables and you switch on your new wireless router. \nBut, the router is not able to establish an Internet connection. \nAfter checking the technical manuals and playing with router settings, you finally give up and you call the ISP operator\'s call centre.\n\n\nThe first thing you hear is a machine voice of the auto responder. \nIt suggests dozen of possible solutions to various problems, but none of those are related to your particular problem. \nAfter a while, the machine connects you to the live operator. After a short discussion, the operator realizes that he cannot help you either. \nSo, he connects you to an engineer, who finally fixes your problem.\n\n\nThat was an example of the Chain of Responsibility.\n\n\nIn essence, we pass an object along a "chain" of potential handlers for that object until one of the handlers handles the request.\nThe Chain of Responsibility allows an object to send a command without knowing which object will receive and handle it. \nThe request is sent from one object to another, making them parts of a chain and each object in this chain can handle the command, \npass it on or do both.\n\n\n'}, {'patternName': 'Command', 'patternUMLFileName': 'command.png', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/command', 'patternId': 'Command', 'patternStructure': '* Structure\n\nThe Command declares an interface for executing an operation. \nThe ConcreteCommand class defines the binding between a Receiver object and an action. \nThe Receiver class knows how to perform the operations associated with carrying out a request. \nAny class may serve as a Receiver. \nThe Invoker class sends the command to carry out a request. \nThe Client class creates a ConcreteCommand object and sets its receiver.\n\n\n', 'patternMotivation': '\nImagine that we are developing a graphical editor. The user can add new text, delete or update existing text.\n\nWhat to do in a case when user does something wrong? The user should be able to return back to the state of the text before the wrong action has \nbeen executed.\n\n\nHow to implement such behavior?\n\n\nOne solution would be to hold a list of the text states. \nIf the text is long and if we store a lot of states of such a long text, we can run out of memory, \nso this solution is not appropriate for our particular scenario.\n\n\nWhat if we consider an idea where the current state of text is a result of execution of a sequence of operations? \nThese operations can be undone, with the effect that the text reverts to a previous state. \nThe operations that have been undone become redoable, so that later model states can be reached again if necessary. \nSo, we will no longer invoke operations on the text directly, but we will create Command objects, which invoke the operations. \nEach text operation will have the appropriate Command object.\n\nThis solution is a Command pattern. \nThe Command pattern issues requests to objects without knowing anything about the operation being requested or about the receiver of the request.\n\n', 'patternStory': '\nWhen your car needs servicing, you visit a Car Service Center. Upon arrival, you explain the problem and you leave the car. \nThe person at reception summarizes the problem and enters it into an order for the Car Technician. \nThe order is queued internally. The Car Technician will receive the request and fix the problem.\n\n', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/command'}, {'patternName': 'Interpreter', 'patternUMLFileName': 'interpreter.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/interpreter', 'patternId': 'Interpreter', 'patternStructure': '* Structure\n\nEfficiency is a big concern for any implementation of this pattern. \nIntroducing your own grammar requires extensive error checking, which will be time consuming for the programmer to implement, \nand needs careful design in order to run efficiently during runtime. \nAlso, as the grammar becomes more complicated, the maintenance effort increases.\n\n\nThe AbstractExpresion defines interface for interpretation. \nThe TerminalExpresion implements the AbstractExpression for literal symbols in the grammar. \nOne object for each literal symbol. \nThe NonterminalExpresion implements AbstractExpression for grammar rules. \nOne class per grammar rule, e.g. the OrExpression Context class, holds global information for the Interpreter. \nThe Client class creates an Abstract Syntax Tree, which represents expression defined in grammar.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/interpreter.jpg "Polish Sign Language - letter C")  \n######  Polish Sign Language - letter C, By Tomt87 (Own work) [CC BY-SA 4.0 (http://creativecommons.org/licenses/by-sa/4.0)], via Wikimedia Commons\n\n\n', 'patternStory': '\nA person who provides an oral translation from one language into another.\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/interpreter', 'patternMotivation': '\n'}, {'patternName': 'Iterator', 'patternUMLFileName': 'iterator.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/iterator', 'patternId': 'Iterator', 'patternStructure': '* Structure\n\nThe Iterator defines an interface for accessing and traversing elements. \nThe ConcreteIterator implements the Iterator interface, keeps track of the current position in the traversal of the aggregate. \nThe Aggregate defines an interface for creating an Iterator object. \nThe ConcreteAgregate class implements the Iterator creation interface to return an instance of the proper ConcreteIterator.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/iterator.jpg "Iterate book page by page")  \n###### Open Book by Dave Dugdale, on Flickr&quot;&nbsp;(<a rel=\'license\' href=\'https://creativecommons.org/licenses/by-sa/2.0/\' target=\'_blank\'>CC BY-SA 2.0</a>)&nbsp;by&nbsp; <a xmlns:cc=\'http://creativecommons.org/ns#\' rel=\'cc:attributionURL\' property=\'cc:attributionName\' href=\'https://www.flickr.com/people/davedugdale/\' target=\'_blank\'>Dave Dugdale</a>\n\n\n', 'patternStory': '\nA book is a set of written, printed sheets bound together into a volume. \nYou can browse through the book page by page, or quickly jump to an interesting chapter. \nThe process of browsing is an example of the Iterator pattern.\n\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/iterator', 'patternMotivation': '\nIn computer science, a data structure is a particular way of organizing and storing data, so that it can be accessed and modified efficiently. \nMore precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations \nwhich can be applied to the data.\n\n\nThere are numerous types of data structures, such as linked lists, arrays, vectors, maps, etc. \nEach collection of the data structure has its own structure and its own way of accessing elements of the collection.\n\n\nIn practice, it is not convenient to access each type of collection in a different way, so it would be nice to have a common interface for \nelement-by-element access to a collection, independent of the collection\xe2\x80\x99s shape.\n\n\nThe Iterator pattern lets you do all this. \nThe key idea is to take the responsibility for access and traversal out of the aggregate object and put it into an Iterator object which \ndefines a standard traversal protocol.\n\nSo, an Iterator pattern provides a way of accessing the elements of an aggregate object sequentially, without exposing its underlying representation.\n\n'}, {'patternName': 'Mediator', 'patternUMLFileName': 'mediator.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/mediator', 'patternId': 'Mediator', 'patternStructure': '* Structure\n\nA Colleague defines an interface for communication with another Colleague via the Mediator. \nFor the ConcreteColleague class, each Colleague class knows its Mediator object, and each Colleague communicates with its mediator \nwhenever it would have otherwise communicated with another colleague. \nThe Mediator defines an interface for communicating with Colleague objects. \nThe ConcreteMediator implements cooperative behavior by coordinating the Colleague objects.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/mediator.jpg "Call Center Taxis Libres")  \n###### Call Center Taxis Libres,By Jquemba (Own work) [Public domain], via Wikimedia Commons \n\n', 'patternStory': "\nA Radio Taxi is an example of the Mediator pattern. \nThe taxi drivers communicate with the Mediator (Radio Taxi Call Center), rather than with each other.\n\n\nWhen a customer needs a taxi, he calls the Radio Taxi Call Center. \nAll taxis have GPS units, which tell the Radio Taxi Call Center the taxis' current locations; there is also a central information system, \nwhich tells which taxi is currently available to serve the customer. \nThe call center will contact the available taxi nearest to customer\xe2\x80\x99s location and send it to serve the customer.\n\n\n", 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/mediator', 'patternMotivation': '\nImagine that we need to develop a flight simulator. Our flight simulator will have base artifacts, like airport and aircraft. \nAn aircraft can take off from the airport, fly in the sky and land on the airport.\n\n\nImagine a scenario when one particular aircraft is landing on the airport: how can that aircraft be sure that the other aircrafts are not \ntrying to land on the same airport at the same time? It is obvious that our aircraft can\'t talk to each and every aircraft which is currently \napproaching the airport.\n\n\nA better approach would be to introduce a mediator, which is a "man in the middle", meaning that all the aircrafts will communicate only with the mediator. \nThe task of ensuring the safe operations of the aircrafts belongs to air traffic controllers, who are mediators. \nThey must coordinate the movements of all the aircrafts, keep them at safe distances from each other, direct them during takeoff and landing, \ndirect them around bad weather and ensure that the air traffic flows smoothly with minimal delays.\n\n\nThe example above is a Mediator pattern. The Mediator pattern defines an object that controls how a set of objects interacts.\n\n\n'}, {'patternName': 'Memento', 'patternUMLFileName': 'memento.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/memento', 'patternId': 'Memento', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/memento.jpg "States of transaction")  \n###### States of transaction \n\n', 'patternStory': '\nTransactions are operations on the database which occur in an atomic, consistent, durable, and isolated fashion. \nA transaction can contain multiple operations on the database; each operation can succeed or fail \xe2\x80\x93 however, a transaction guarantees that, \nif all operations succeed, the transaction would commit and would be final. \nAnd if any operation fails, then the transaction would fail and all operations would roll back and leave the database in its original state, \nas if nothing has happened.\n\nThis rollback mechanism uses the Memento design pattern.\n \n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/memento', 'patternMotivation': '\nModerModern cars have brakes on all four wheels, operated by a hydraulic system. \nThe brakes may be disc type or drum type.\n\n\nThe front brakes play a greater part in stopping the car than the rear ones, because braking throws the car weight forward on to the front wheels.\n\n\nMany cars therefore have disc brakes, which are generally more efficient, at the front, and drum brakes at the rear.\n\n\nImagine a scenario in which we need to replace the drum brakes at the rear by ourselves? \nHow  do we ensure that the new drum brake has all the necessary pieces in their proper places? \nOne solution might be to use the Memento.\n\n\nThe drums are removed from both sides, exposing both the right and left brakes. \nOnly one side is disassembled and the other serves as a Memento of how the brake parts fit together. \nThe other side is disassembled only after the job has been completed on one side. \nWhen the second side is disassembled, the first side acts as the Memento.\n\n\nThus we have an example of the Memento design pattern. \nMemento design pattern helps to restore an object\xe2\x80\x99s state to it previous state.\n\n\n'}, {'patternName': 'Observer', 'patternUMLFileName': 'observer.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/observer', 'patternId': 'Observer', 'patternStructure': "* Structure\n\nThe Observer defines an updating interface for objects which should be notified of changes in a subject. \nThe Subject knows its observers. \nA subject can be observed by any number of Observer objects. \nThe ConcreteSubject stores the state of interest to ConcreteObserver objects and sends notifications to its observers when its state changes. \nThe ConcreteObserver maintains a reference to a ConcreteSubject object, stores the state that should stay consistent with the subject's and \nimplements the Observer updating interface to keep its state consistent with the subject's.\n\n\n", 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/observer.jpg "Newsletter Banner")  \n###### Newsletter Banner by, <a href="https://commons.wikimedia.org/wiki/User:Stevie_Benton_(WMUK)">Stevie Benton</a>, <a href="https://commons.wikimedia.org/wiki/File:Newsletter-banner-v2.jpg">Newsletter-banner-v2</a>, <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a>\n\n', 'patternStory': '\nKeep me updated.\n\n\nA newsletter subscription demonstrates the Observer pattern. \nA newsletter is a regularly distributed publication that is generally about one main topic of interest to its subscribers. \nThe subscribers can subscribe or unsubscribe to the newsletters.\n\n\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/observer', 'patternMotivation': '\nImagine that we are developing a computer game.\n\n\nOne feature of our game will be the awards system. \nPlayers will earn dozens of different badges for completing specific milestones during the game.\n\n\nWhen players pass or reach a certain point in the game, for example jump over a complex fence, we need to catch that part of the code and calculate the award.\n\n\nBut, how should we implement such a feature?\n\n\nOne approach would be to find a place in the code where specific milestones are completed and extend those places with code which calculates the \nawards. This approach is not flexible, it is not intuitive, and makes our code complex and difficult and violates the single responsibility principle.\n\n\nAnother approach would be to create award events in the code, where specific milestones are completed: award events are then published as \nnotifications, regardless of who receives the notification. \nThe awards system is listening to all award events and implements all the necessary logic.\n\n\nThis solution is the Observer pattern.\n\n\nThe Observer pattern defines a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and \nupdated automatically.\n\n\n'}, {'patternName': 'State', 'patternUMLFileName': 'state.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/state', 'patternId': 'State', 'patternStructure': '* Structure\n\nThe State defines an interface for encapsulating the behavior associated with a particular state of the Context. \nThe ConcreteState implements a behavior associated with the state of the Context. \nThe Context class maintains an instance of a ConcreteState subclass which defines the current state.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/state.jpg "Human Pregnancy")  \n###### <a href="https://commons.wikimedia.org/wiki/File:Pregnant_graffiti.jpg">Pregnant graffiti</a> by, <a href="http://flickr.com/photos/19616008@N00">Petteri Sulonen from Helsinki, Finland</a>, <a href="https://creativecommons.org/licenses/by/2.0/legalcode">CC BY 2.0</a>\n\n', 'patternStory': '\nBehavior depends on its state.\n\n\nPregnancy is a time of great physical and emotional change for women. \nEverything from the size of her belly to the speed at which her heart beats will change over the nine months leading up to the childbirth. \nPartly as the result of hormonal fluctuations, and partly due to the physical strain of carrying extra body weight, \npregnant women can expect to buy new bras, search for ways to alleviate swollen ankles, gasp for breath after climbing a few stairs, \nand marvel at how quickly their nails grow.\n\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/state', 'patternMotivation': "\nImagine that we need to implement a state machine. \nWe begin with a few states, and a few simple conditions for those states. \nOur initial State machine is implemented using if/else blocks, which are checking the current state and which perform the appropriate actions.\n\n\nBut, the number of states gradually increases over time. \nIn addition, the conditions for reaching certain states become more complex. \nOur 'if/else' \xe2\x80\x93 based state machine has more and more 'if/else' blocks and it becomes really difficult to maintain and debug such a code base.\n\n\nIs there a more elegant way to implement the State Machine?\n\n\nAnother approach would be that, for every possible state, a separate class is implemented over a common  interface, with the state related behavior. \nThe Context class will contain a reference to a state object, which represents its current state. \nInstead of acting on its own, the context will delegate the execution to the state object. \nTo change the state of the context, one would pass another state object to the context.\n\n\nThis solution is an example of the State pattern.\n\n\nThe State pattern allows an object to alter its behavior when its internal state changes.\n\n\n"}, {'patternName': 'Strategy', 'patternUMLFileName': 'strategy.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/strategy', 'patternId': 'Strategy', 'patternStructure': '* Structure\n\nThe Strategy declares an interface common to all supported algorithms. \nThe ConcreteStrategy implements the algorithm using the Strategy interface. \nThe Context uses this interface to call the algorithm defined by a ConcreteStrategy.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/strategy.jpg "Credit Card")  \n###### Credit Card&nbsp;(<a rel=\'license\' href=\'https://creativecommons.org/licenses/by/2.0/\' target=\'_blank\'>CC BY 2.0</a>)&nbsp;by&nbsp;<a xmlns:cc=\'http://creativecommons.org/ns#\' rel=\'cc:attributionURL\' property=\'cc:attributionName\' href=\'https://www.flickr.com/people/mecklenburg/\' target=\'_blank\'>ThomasKohler</a>\n\n', 'patternStory': '\nSelect an algorithm at runtime.\n\n\nThe payment options in a Shopping Cart are an example of a Strategy. \nUser can choose various payment options, such as Master Card, Amex or PayPal. \nAny of these payment options will pay for the items in the Shopping Cart, and they can be used interchangeably. \nThe user may choose the Strategy based on his possibilities and preferences.\n\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/strategy', 'patternMotivation': "\nImagine that we need to implement a network load balancer. \nThe Load balancer serves as the single point of contact for clients: it distributes incoming traffic across multiple targets, \nwhich increases the availability and capability of your application.\n\n\nThe question is: how will the load balancer distribute the incoming traffic? \nWe can have various algorithms, like round robin, ip-hash, least connected, etc. \nNew algorithms can be introduced over time. \nSo, it is obvious that an algorithm for traffic distribution can be implemented in different ways.\n\n\nA straight solution would be to implement a few algorithms and hide the invocation of the algorithm in an 'if/then' or in a 'switch' statement.\n\n\nIs the proposed solution flexible enough?\n\n\nAnother solution would be to define a common interface for our algorithm and then encapsulate the behavior of an algorithm as an object which \nimplements a common interface. \nDuring runtime we can select which object to use and many different behaviors can be implemented without \ncreating huge 'if/then' or 'switch' statements.\n\n\nThis solution is a Strategy pattern. \n\nThe Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. \nThe Strategy lets the algorithm vary independently from the clients that use it.\n\n\n"}, {'patternName': 'Template Method', 'patternUMLFileName': 'templatemethod.png', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/templatemethod', 'patternId': 'TemplateMethod', 'patternStructure': '* Structure\n\nThe AbstractClass defines abstract primitive operations that concrete subclasses should implement. \nThe ConcreteClass implements the abstract primitive operations to carry out subclass-specific steps of the algorithm.\n\n\n', 'patternMotivation': '\nImagine that we need to implement an application which performs various operations on a database. We decide to use JDBC, which is a standard Java interface for accessing a relational database. \nUsing JDBC for database operations (for example, a read operation via select SQL statement), the user must execute following steps:\n\n* connect to database   \n* execute SQL statement   \n* process data which are gathered from database   \n* close database connection   \n* handle errors if something goes wrong   \n\nIf we implement such a database operation several times for various read operations, we will find out that we are repeating some steps. \nWe can also see that some steps are always the same, i.e. \'connect to database\', \'close database connection\', \'handle errors\'. \nThe remaining steps, such as \'execute SQL statement\' and \'process data obtained from the database\' are different for each read operation. \nSo, let\'s call those steps which are the same \'invariant\' and remaining steps \'variant\'.\n\n\nWe now implement invariant steps inside an abstract base class, while the variant steps are either given a default implementation, or no \nimplementation at all. The variant steps represent "hooks", or "placeholders", that may, or must, be supplied by the component\'s client in a \nconcrete derived class.\n\n\nThe solution in the above example is the Template Method design pattern.\n\n\nThe Template Method defines a skeleton of an algorithm in an operation. Algorithm will have a common part and a specialized part.\n\n', 'patternStory': '\nDaily routine is example of the Template Method. \nEvery day people get up (common part), go to work (common part), do their job (specialized part), go home (common part) and go to sleep (common part). \nThere are people with different professions, such as engineers, teachers, etc. During work, an engineer will fix machines, \nwhile teacher will teach children how to read and write. \nAt the end of the day they go home, have dinner and go to sleep.\n\n', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/templatemethod'}, {'patternName': 'Visitor', 'patternUMLFileName': 'visitor.png', 'patternSourceCodePackageName': '/src/main/java/com/hundredwordsgof/visitor', 'patternId': 'Visitor', 'patternStructure': '* Structure\n\nThe Visitor declares a Visit operation for each class of ConcreteElements in the object structure. \nThe ConcreteVisitor implements each operation declared by the Visitor. \nEach operation implements a fragment of the algorithm defined for the corresponding class of objects in the structure.  \nThe Element defines an Accept operation that takes a visitor as an argument. \nThe ConcreteElement implements an Accept operation that takes a visitor as an argument. \nThe ObjectStructure provides a composition or collection of the elements and allows the visitor to visit its elements.\n\n\n', 'patternImage': '\n\n![alt text](https://github.com/dstar55/100-words-design-patterns-java/blob/gh-pages-resources/visitor.jpg "Cashier in Supermarket")  \n###### Cashier in Supermarket, CC0 Public Domain\n\n', 'patternStory': '\nShopping in a supermarket is an example of the Visitor pattern. You pick products and put them in a shopping cart. \nWhen you get to the checkout, the cashier acts as a visitor, taking the disparate set of elements, some with prices and others that need to be \nweighted, in order to provide you with the total to be paid.\n\n', 'patternTestSourceCodePackageName': '/src/test/java/com/hundredwordsgof/visitor', 'patternMotivation': '\nImagine that we need to implement a compiler. \nA compiler is a program which transforms code written in one programming language (the source language) into another programming \nlanguage (the target language).\n\nThe compiler functionality is divided into two major blocks: a front-end and a back-end. \nThe front-end block comprises of a sequence of several phases, with each stage taking input from its previous stage, \nmodifying it and producing its own representation of the source program and passing it to the next phase. \nThe front-end includes three main stages, which are called the lexical, the syntax and the semantic analysis.\n\n\nThe first phase takes the source code as a stream of characters and identifies distinct words (tokens), such as variable names, keywords and \npunctuators. \nThe second phase determines the validity of syntactic organization of the program and produces the Abstract Syntax Tree (AST). \nThe semantic analysis checks whether the AST follows the rules of a language (type checking, name resolution, etc.).\n\n\nAST, which represents the program written in source code, is created during the second phase and is used in later phases of the compiling process \nfor operations such as type-checking, code generation, code optimization, flow analysis, pretty-printing, code instrumentation, etc.\n\n\nMost of these operations will need to treat nodes that represent assignment statements differently from nodes that represent variables or \narithmetic expressions. \nDistributing all these operations across the various node classes leads to a system that\'s hard to understand, maintain and change.\n\n\nIt would be better if each new operation could be added separately, and if the node classes were independent of the operations that apply to them. \nIf we package related operations in a separate object, called a visitor, and pass it to elements of the AST as it is traversed, \nthen when an element of the AST "accepts" the visitor, it sends a request to the visitor that encodes the element\'s class.\n\n\nThe solution in the above example is a Visitor design pattern.\n\nThe Visitor allows one or more operations to be applied to a set of objects at runtime, decoupling the operations from the object structure.\n\n\n'}]
Generating content ...
Generating page ... ./gh-pages/_drafts/Singleton.md
patternStructure
Generating page ... ./gh-pages/_drafts/Prototype.md
patternStructure
Generating page ... ./gh-pages/_drafts/Builder.md
patternStructure
Generating page ... ./gh-pages/_drafts/FactoryMethod.md
patternStructure
Generating page ... ./gh-pages/_drafts/AbstractFactory.md
patternStructure
Generating page ... ./gh-pages/_drafts/Adapter.md
patternStructure
Generating page ... ./gh-pages/_drafts/Bridge.md
patternStructure
Generating page ... ./gh-pages/_drafts/Composite.md
patternStructure
Generating page ... ./gh-pages/_drafts/Decorator.md
patternStructure
Generating page ... ./gh-pages/_drafts/Facade.md
patternStructure
Generating page ... ./gh-pages/_drafts/Flyweight.md
patternStructure
Generating page ... ./gh-pages/_drafts/Proxy.md
patternStructure
Generating page ... ./gh-pages/_drafts/ChainOfResponsibility.md
patternStructure
Generating page ... ./gh-pages/_drafts/Command.md
patternStructure
Generating page ... ./gh-pages/_drafts/Interpreter.md
patternStructure
Generating page ... ./gh-pages/_drafts/Iterator.md
patternStructure
Generating page ... ./gh-pages/_drafts/Mediator.md
patternStructure
Generating page ... ./gh-pages/_drafts/Memento.md
patternStructure
Generating page ... ./gh-pages/_drafts/Observer.md
patternStructure
Generating page ... ./gh-pages/_drafts/State.md
patternStructure
Generating page ... ./gh-pages/_drafts/Strategy.md
patternStructure
Generating page ... ./gh-pages/_drafts/TemplateMethod.md
patternStructure
Generating page ... ./gh-pages/_drafts/Visitor.md
patternStructure
Generating content ... done
